---
layout: video
title: "Create DynamoDB Tables for EC2 EKS API SNS SQS"
description: "Compact guide to create DynamoDB tables and connect database to EC2 EKS API Gateway SNS and SQS with practical steps and best practices"
video_host: "youtube"
video_id: "XAbjvmrbN-A"
upload_date: "2025-10-01T11:11:11+11:11"
duration: "PT58S"
thumbnail_url: "https://i.ytimg.com/vi/XAbjvmrbN-A/maxresdefault.jpg"
content_url: "https://youtu.be/XAbjvmrbN-A"
embed_url: "https://www.youtube.com/embed/XAbjvmrbN-A"
publisher_name: "certificationExams.pro"
publisher_logo: "/assets/images/logo-512.png"
in_language: "en"
is_accessible_for_free: true
tags:
  - DynamoDB
  - AWS
  - EC2
  - EKS
  - API Gateway
  - SNS
  - SQS
  - NoSQL
  - AWS CLI
  - IAM
---

<p>So you need DynamoDB to behave like a polite roommate and play nice with EC2, EKS, API Gateway, SNS and SQS. Good news, it can do that. Bad news, if you pick the wrong keys or permissions it will silently ruin your day. This guide walks through table design, the AWS CLI create steps, IAM best practices, and how to wire messaging and compute into a reliable NoSQL pipeline with minimal chaos.</p>

<h2>Pick keys and indexes like you want predictable performance</h2>
<p>DynamoDB loves even traffic. If your partition key funnels everyone into the same shard you will hit hot partitions and throttles, and then you will have feelings. Use a composite primary key when you need range queries, and add Global Secondary Indexes for alternate access patterns. Think about access patterns first, then model tables to match. This is the reverse of winging it and hoping the database forgives you.</p>
<ul>
  <li>Primary key for uniqueness and query patterns</li>
  <li>Composite key when you need sort order or ranges</li>
  <li>GSI for queries that do not fit the main key</li>
  <li>Avoid attributes that require scanning large datasets</li>
</ul>

<h2>Create the table with the console or the AWS CLI</h2>
<p>For unpredictable traffic choose on demand billing, for steady workloads use provisioned capacity and auto scaling. Use the console when you are in a hurry or the CLI when you want repeatable infrastructure as code. Here is a basic CLI example that actually works and will not lecture you.</p>
<pre><code>aws dynamodb create-table --table-name MyTable --attribute-definitions AttributeName=Id,AttributeType=S --key-schema AttributeName=Id,KeyType=HASH --billing-mode PAY_PER_REQUEST</code></pre>
<p>If you need provisioned capacity add the read and write capacity units and consider autoscaling policies. Remember to create GSIs at table creation when possible to avoid backfilling large data sets later.</p>

<h2>Set IAM roles and policies with least privilege</h2>
<p>Grant the minimum permissions required and avoid making broad statements that basically hand the keys to the kingdom. For EC2 use instance roles. For EKS prefer IAM roles for service accounts so individual pods do not get global powers. For API Gateway use a role for integrations or let Lambda handle the table access under a tightly scoped role.</p>
<ul>
  <li>EC2 instances: attach an instance role with dynamodb GetItem PutItem Query UpdateItem permissions scoped to the table</li>
  <li>EKS pods: use IAM Roles for Service Accounts to assign fine grained access</li>
  <li>API Gateway: use a Lambda role or an integration role with only the needed actions</li>
  <li>SNS and SQS: grant publish and receive permissions only where needed</li>
</ul>

<h2>Integrate DynamoDB with EC2, EKS, API Gateway, SNS and SQS</h2>
<p>From EC2 use your favorite AWS SDK to call DynamoDB. From EKS attach the service account role so pods can make requests without long lived credentials. API Gateway can call Lambda to perform CRUD operations or use direct integration in some cases if you want fewer moving parts. Use SNS to publish event notifications and SQS to queue background work that updates the table. This keeps your writes reliable and your front end snappy.</p>
<p>Example patterns</p>
<ul>
  <li>API Gateway triggers Lambda which updates DynamoDB and publishes to SNS for fan out</li>
  <li>SNS publishes messages that multiple subscribers can handle, including a worker that writes to DynamoDB</li>
  <li>SQS holds work that a fleet of EKS pods consume, process, and then update the table</li>
</ul>

<h2>Monitor capacity and tune before things break</h2>
<p>Enable CloudWatch metrics and set alarms for read and write throttles, consumed capacity, and system errors. If you use provisioned capacity pair it with autoscaling. If you use on demand billing and your pattern is bursty you still need to look at latency and throttles. Remove unused indexes to reduce cost, and periodically review access patterns so your table design evolves as your app does.</p>

<h3>Practical checklist for first deploy</h3>
<ul>
  <li>Define access patterns and choose keys and GSIs before creating the table</li>
  <li>Pick PAY_PER_REQUEST for spiky traffic or provisioned capacity for predictable loads</li>
  <li>Create minimal IAM roles for EC2, EKS, Lambda, SNS and SQS integration</li>
  <li>Use SNS for notifications and SQS for durable background processing</li>
  <li>Enable CloudWatch alarms and autoscaling where appropriate</li>
</ul>

<p>If you follow this plan your DynamoDB will be less dramatic than your last production incident. If you do not, well you will learn a lot while debugging throttles at 2 a m. Either way you win knowledge and possibly a minor heart condition. Happy building.</p>

