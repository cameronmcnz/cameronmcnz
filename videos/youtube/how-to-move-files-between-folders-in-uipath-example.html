---
layout: video
title: "How to move files between folders in UiPath Example"
description: "Quick guide to moving files between folders using UiPath with Move File activity variables and basic error handling"
video_host: "youtube"
video_id: "Eu3x-O2FdxA"
upload_date: "2025-10-01T11:11:11+11:11"
duration: "PT3M33S"
thumbnail_url: "https://i.ytimg.com/vi/Eu3x-O2FdxA/maxresdefault.jpg"
content_url: "https://youtu.be/Eu3x-O2FdxA"
embed_url: "https://www.youtube.com/embed/Eu3x-O2FdxA"
publisher_name: "certificationExams.pro"
publisher_logo: "/assets/images/logo-512.png"
in_language: "en"
is_accessible_for_free: true
tags:
  - UiPath
  - RPA
  - Move File
  - File Management
  - Automation
  - UiPath Tutorial
  - Robotic Process Automation
  - Workflow
  - Exception Handling
  - Logging
---

<h2>Why this matters</h2>
<p>Moving files sounds boring until that one process nukes a folder or your robot decides to play hide and seek with a locked file. This guide walks through a tidy UiPath workflow for file management that is easy to read and hard to break. Expect variables, checks, the Move File activity, and some polite failure handling so your automation does not throw a tantrum in production.</p>

<h2>Overview of the approach</h2>
<p>High level first then the nitty gritty. You will set up string variables for source and destination paths, validate folders with <code>Directory.Exists</code>, use the UiPath Move File activity to perform the transfer, and wrap everything in Try Catch blocks to handle exceptions like <code>System.IO.IOException</code>. Add logging so you know what happened without having to interrogate your robot like a detective.</p>

<h3>What you will need</h3>
<ul>
  <li>UiPath Studio with classic activities or the equivalent package that includes Move File</li>
  <li>Basic string variables such as <code>sourcePath</code> and <code>destinationPath</code></li>
  <li>Permissions to read and write the target folders</li>
</ul>

<h2>Step 1 Prepare variables and folder paths</h2>
<p>Create clear string variables. For example use <code>sourcePath</code> and <code>destinationPath</code>. Prefer full absolute paths to avoid surprises when the robot runs from a different working folder. If you need to build paths use <code>Path.Combine</code> instead of string concatenation to keep things sane.</p>
<p>Always check folder existence with <code>Directory.Exists(sourcePath)</code> and <code>Directory.Exists(destinationPath)</code> before moving a file. That simple check avoids sending the robot on a wild goose file chase.</p>

<h2>Step 2 Use the Move File activity</h2>
<p>Drag the Move File activity into your sequence and bind its properties to the variables you created. The activity does the actual file transfer with minimal fuss. If you expect name clashes add logic to handle overwrites first.</p>
<p>For overwriting use a conditional check. If the destination file exists then either skip the move, rename the destination, or remove it with a Delete activity before the move depending on your business rule. Keep the decision explicit so the workflow is predictable.</p>

<h2>Step 3 Add exception handling and logging</h2>
<p>Wrap file operations in a Try Catch. Catch <code>System.IO.IOException</code> and other relevant exceptions to handle locked files and IO issues. Use Log Message activities to record what happened and why. Logging saves you from staring at logs wondering why the robot decided to nap.</p>
<p>Example catch actions</p>
<ul>
  <li>On IOException log the file name and retry later or move the file to a quarantine folder</li>
  <li>On DirectoryNotFoundException log the missing path and halt the operation</li>
  <li>Always include a fallback catch to log unexpected exceptions for later analysis</li>
</ul>

<h2>Step 4 Test with edge cases</h2>
<p>Run the workflow with sample files and try edge cases such as missing folders, permission errors, and locked files. Observe the logs and refine checks until behavior matches expectations. Manual testing prevents deploying a tantrum prone robot into production.</p>

<h3>Tip for preventing overwrites</h3>
<p>Append a timestamp to destination names when duplicates are possible. For example construct a file name with <code>DateTime.Now.ToString("yyyyMMdd_HHmmss")</code> to keep history and avoid accidental overwrites without complex logic.</p>

<h2>Putting it together in a sample flow</h2>
<ol>
  <li>Assign <code>sourcePath</code> and <code>destinationPath</code></li>
  <li>If not Directory.Exists(sourcePath) then Log Message and stop</li>
  <li>If not Directory.Exists(destinationPath) then Log Message and create or stop based on policy</li>
  <li>If File.Exists(destinationFile) then apply your overwrite policy or add timestamp</li>
  <li>Try Move File activity and catch IO exceptions with meaningful logging</li>
</ol>

<h2>Final notes</h2>
<p>This pattern keeps file management in UiPath reliable and maintainable. It scales from simple one off moves to larger automation chains where robust exception handling and clear logs make your life easier. And yes your robot will still occasionally learn to be dramatic, but this setup gives it far fewer chances to ruin the day.</p>

