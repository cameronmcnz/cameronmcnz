---
layout: video
title: "Build Java apps in Jenkins with Maven Example"
description: "Build Java apps in Jenkins using Maven with a simple pipeline for automated builds tests and artifact publishing"
video_host: "youtube"
video_id: "nvqIrHH8v3c"
upload_date: "2025-10-01T11:11:11+11:11"
duration: "PT7M17S"
thumbnail_url: "https://i.ytimg.com/vi/nvqIrHH8v3c/maxresdefault.jpg"
content_url: "https://youtu.be/nvqIrHH8v3c"
embed_url: "https://www.youtube.com/embed/nvqIrHH8v3c"
publisher_name: "certificationExams.pro"
publisher_logo: "/assets/images/logo-512.png"
in_language: "en"
is_accessible_for_free: true
tags:
  - Jenkins
  - Maven
  - Java
  - Jenkinsfile
  - CI
  - CD
  - Pipeline
  - Build
  - Automated Testing
  - DevOps
---

<article>
  <p>Yes you can build Java like a grown up and let Jenkins do the heavy lifting. This guide walks through a practical Maven and Jenkins pipeline that compiles code runs tests and stores artifacts so you can stop doing the same five steps manually every time someone pushes a typo.</p>

  <h2>What you will need</h2>
  <p>Keep it simple and realistic. You will need a standard Maven project with a pom.xml JUnit tests so the pipeline has something to report a Jenkins server with JDK and Maven configured and a Git repository that Jenkins can access with credentials. A Multibranch pipeline makes life easier if you like branches more than chaos.</p>

  <h2>Prepare the Maven project</h2>
  <p>Create the usual Maven layout and add a pom.xml with groupId artifactId and version. Add JUnit tests so builds can fail in interesting ways and the surefire reports have something to show. If you want faster builds set up a shared local repository folder so agents can cache dependencies between runs.</p>

  <h2>Configure Jenkins server</h2>
  <p>Install a JDK and register a Maven installation under Global Tool Configuration. Create credentials for your Git host and decide whether a Multibranch pipeline or a single pipeline job fits your workflow. Multibranch will scan branches automatically which is great if developers like making dozens of feature branches for fun.</p>

  <h2>Example Jenkinsfile</h2>
  <p>Here is a short declarative pipeline to get you started. It checks out code builds with Maven runs tests publishes JUnit results and archives artifacts.</p>

  <pre><code>pipeline {
  agent any
  tools {
    jdk 'jdk11'
    maven 'maven3'
  }
  stages {
    stage('Checkout') {
      steps {
        checkout scm
      }
    }
    stage('Build') {
      steps {
        sh 'mvn clean package'
      }
    }
    stage('Test') {
      steps {
        sh 'mvn test'
        junit 'target/surefire-reports/*.xml'
      }
    }
    stage('Archive') {
      steps {
        archiveArtifacts 'target/*.jar'
      }
    }
  }
  post {
    always {
      echo 'Pipeline finished'
    }
  }
}
</code></pre>

  <h2>Run the pipeline and handle failures</h2>
  <p>Trigger a build manually or push a commit and watch the console log as Maven downloads dependencies compiles code runs tests and packages artifacts. If tests fail inspect the surefire reports in target for stack traces and flaky assertions. Fix tests or fix code but do not fix blame settings.</p>

  <h3>Agent types and commands</h3>
  <p>On Unix agents use sh 'mvn ...' and on Windows agents use bat 'mvn ...'. Pick the right command for the agent and do not try to run Windows commands on Unix unless you enjoy learning painful lessons.</p>

  <h2>Publish artifacts and test results</h2>
  <p>Use archiveArtifacts to keep build outputs and use the junit step to publish test results to the Jenkins UI. When the code reaches release quality add steps to deploy to a Maven repository or Nexus using your preferred credentials plugin and repository manager.</p>

  <h2>Performance and caching tip</h2>
  <p>Cache Maven dependencies on build agents by sharing a local repository or mounting a cache directory. That can cut build time dramatically when many builds run and developers push frequently.</p>

  <h2>Recap</h2>
  <p>This walkthrough covered wiring a Maven project into Jenkins creating a Jenkinsfile running a declarative pipeline collecting JUnit reports and archiving artifacts. The result is a repeatable CI workflow that reduces manual steps speeds feedback and gives you more time to write clever commit messages.</p>
</article>

